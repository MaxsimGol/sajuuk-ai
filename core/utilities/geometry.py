# core/utilities/geometry.py

import math
from typing import TYPE_CHECKING, Set

import numpy as np

# This block was missing. It provides the definitions for type hints.
if TYPE_CHECKING:
    from sc2.position import Point2
    from sc2.units import Units


def create_threat_map(
    enemy_units: "Units", map_size: tuple[int, int], threat_radius: int = 15
) -> np.ndarray:
    """
    Generates a 2D numpy array representing a "threat map" of the battlefield.

    Each cell in the map contains a score representing the cumulative threat
    posed by nearby enemy units. This is useful for finding safe locations
    for army positioning or expansion.

    :param enemy_units: A collection of enemy units to source threat from.
    :param map_size: A tuple (width, height) of the map.
    :param threat_radius: The maximum distance from an enemy unit that its
    threat will be projected.
    :return: A 2D numpy array where higher values indicate greater danger.
    """
    threat_map = np.zeros(map_size, dtype=np.float32)

    for unit in enemy_units:
        # For simplicity, we can use a basic threat value or incorporate
        # the calculate_threat_value function from unit_value.py later.
        threat_value = 10 + unit.radius  # Basic threat score
        pos = unit.position.rounded

        # Get a bounding box for the threat area to avoid iterating the whole map
        x_min = max(0, pos.x - threat_radius)
        x_max = min(map_size[0], pos.x + threat_radius + 1)
        y_min = max(0, pos.y - threat_radius)
        y_max = min(map_size[1], pos.y + threat_radius + 1)

        for x in range(x_min, x_max):
            for y in range(y_min, y_max):
                dist_sq = (pos.x - x) ** 2 + (pos.y - y) ** 2
                if dist_sq <= threat_radius**2:
                    # Apply a falloff effect: threat is highest at the center
                    falloff = 1 - (math.sqrt(dist_sq) / threat_radius)
                    threat_map[x, y] += threat_value * falloff

    return threat_map


def find_safe_point_from_threat_map(
    threat_map: np.ndarray, reference_point: "Point2", search_radius: int = 20
) -> "Point2":
    """
    Finds the point with the lowest threat score on the map within a given
    search radius of a reference point.

    :param threat_map: The 2D numpy array generated by create_threat_map.
    :param reference_point: The central point to search around.
    :param search_radius: The radius to search for a safe point.
    :return: The Point2 location with the minimum threat in the area.
    """
    best_point = reference_point
    min_threat = float("inf")

    x_min = max(0, int(reference_point.x - search_radius))
    x_max = min(threat_map.shape[0], int(reference_point.x + search_radius + 1))
    y_min = max(0, int(reference_point.y - search_radius))
    y_max = min(threat_map.shape[1], int(reference_point.y + search_radius + 1))

    for x in range(x_min, x_max):
        for y in range(y_min, y_max):
            threat = threat_map[x, y]
            if threat < min_threat:
                min_threat = threat
                best_point = Point2((x, y))

    return best_point
